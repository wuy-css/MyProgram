using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MyConsoleMEF
{
    class 概念
    {
        //一、概念
        //值类型：直接存储值，在栈上存储其值
        //注：值类型变量声明后，不管是否已经赋值，编译器为其分配内存
        //引用类型：存储对其值的引用，在栈上存储地址，在堆上存储值
        //注：引用类型当声明一个类时，只在栈中分配一小片内存用于容纳一个地址，而此时并没有为其分配堆上的内存空间，当使用new 创建一个类的实例时，分配堆上的空间，并把堆上空间的地址保存到栈上分配的小片空间中。
        // 二、区别
        // 值类型和引用类型有何区别？
        //相同点：
        //引用类型可以实现接口，值类型当中的结构体也可以实现接口；
        //引用类型和值类型都继承自System.Object类；

        //不同点：
        //值类型实例通常时在线程栈上分配的（静态分配），但是在某些情形下可以存储在栈中
        //引用类型的对象总是在进程对方中分配（动态分配）

        //值类型在栈内分配空间大小因变量类型而异
        //引用类型在栈内的空间大小相同

        //将一个值类型变量赋值给领域给值类型变量时，将复制包含的值
        //引用类型变量的赋值只复制对对象的引用，而不复制对象本身

        //值类型不可能派生出新的类型：所有的值类型均隐士派生自System.ValueType
        //值类型不可能包含null值
        //三、构造函数在结构和类中的区别
        //类当中，默认有一个无参数的构造函数，当在类中写一个有参数的构造函数，默认无参的构造函数被取代。

        //类中写构造函数参数列表中参数个数可以不确定

        //    在结构中，默认有一个无参数的构造函数，当在类中写一个有参数的构造函数，默认的无参的构造函数还存在，没有被取代。

        //    在结构中写构造函数要把所有的字段都要完全赋值。

        //类属于引用类型，结构属于值类型。

        //四、堆和栈的区别
        //栈是编译期间就分配好的内存空间，因此代码中必须旧栈的大小有明确的定义；局部值类型变量、值类型参数等都在栈内存中

        //堆是程序运行期间动态分配的内存空间，可以根据程序的运行情况确定要分配的堆内存的大小。

        //五、.Net中哪些是值类型？哪些是引用类型？
        //值类型：
        //       基本数据类型：整型:int
        //                              长整形:long
        //                              浮点型:float（32位）double (64位)
        //                              字符型:char
        //                              布尔型:bool
        //       枚举类型：枚举:enum
        //       结构类型：结构：struct
        //引用类型：
        //       类：
        //              基类：System.Object
        //              字符串：string
        //              自定义类：class
        //       接口：interface
        //      数组：in[] , string[]

        //类和结构的区别
        //1 类是引用类型 结构是值类型
        //2 类可以继承 结构不能继承
        //3 类有默认的构造函数 结构没有默认的不带参数的构造函数

        //OOP和SOA应该没有对比性吧。OOP是一种编程模型，强调将复杂的逻辑分解出小的模块，特性是继承，封装和多态 。
        //而SOA是一个技术框架，技术框架和编程模型应该说不是一码事吧？SOA的思想是将业务逻辑封装成服务或者中间件
        //提供给应用程序来调用，当然其组件化思想是继承和发扬了OOP的优点。

        //XmlSerializer是将对象的属性和字段进行序列化和反序列化的，序列化成为xml数据，
        //反序列化再将xml转换成对象。应该至少需要ACL权限中的读权限.

        //1、动态编译（dynamic compilation）指的是“在运行时进行编译”；与之相对的是事前编译（ahead-of-time compilation，
        //简称AOT），也叫静态编译（static compilation）。
        //2、JIT编译（just-in-time compilation）狭义来说是当某段代码即将第一次被执行时进行编译，因而叫“即时编译”。
        //JIT编译是动态编译的一种特例。JIT编译一词后来被泛化，时常与动态编译等价；但要注意广义与狭义的JIT编译所指的区别。
        //3、自适应动态编译（adaptive dynamic compilation）也是一种动态编译，但它通常执行的时机比JIT编译迟，
        //先让程序“以某种式”先运行起来，收集一些信息之后再做动态编译。这样的编译可以更加优化。

        //对象一致是指两个对象是同一个对象，引用相同。而对象相等是指两个对象的值相同，但引用不一定相同

        //gacutil /l | find /i “Corillian” 这句命令的作用是什么？全局程序集缓存中如果有Corillian就更新该程序集，没有就安装
        //sn -t foo.dll 这句命令是干嘛的？显示程序集foo.dll的公钥标记

        //RPC 全称 Remote Procedure Call——远程过程调用。RPC技术简单说就是为了解决远程调用服务的一种技术，使得调用者像调用本地服务一样方便透明。
        //数据序列化：
        //什么是序列化？序列化就是编码的过程，把对象或者数据结构转化成二进制字节码的过程。
        //而反序列化就是把二进制字节码转化成数据结构或者对象。只有经过序列化后的数据才能在网络中传输。
        //I/O模型：
        //客户端和服务端的通信依赖Socket I/O。I/O 模型又可以分为：传统的阻塞 I/O（Blocking I/O）、
        //非阻塞 I/O（Non-blocking I/O）、I/O 多路复用（I/O multiplexing）、异步 I/O（Asynchronous I/O）
        //1、首先要明确一点：RPC可以用HTTP协议实现，并且用HTTP是建立在 TCP 之上最广泛使用的 RPC，但是互联网公司往往用自己的私有协议，比如鹅厂的JCE协议，私有协议不具备通用性为什么还要用呢？因为相比于HTTP协议，RPC采用二进制字节码传输，更加高效也更加安全。
        //2、现在业界提倡“微服务“的概念，而服务之间通信目前有两种方式，RPC就是其中一种。RPC可以保证不同服务之间的互相调用。即使是跨语言跨平台也不是问题，让构建分布式系统更加容易。
        //3、RPC框架都会有服务降级、流量控制的功能，保证服务的高可用。//https://blog.csdn.net/wangguohe/article/details/81536550?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164109692716780366522195%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164109692716780366522195&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-81536550.pc_search_all_es&utm_term=RPC&spm=1018.2226.3001.4187

        //DCOM（分布式组件对象模型,分布式组件对象模式）是一系列微软的概念和程序接口，利用这个接口，客户端程序对象能够请求来
        //自网络中另一台计算机上的服务器程序对象。DCOM基于组件对象模型（COM），COM提供了一套允许同一台计算机上的客户端和服务
        //器之间进行通信的接口（运行在Windows95或者其后的版本上）

        //        Dxdiag是Windows的DirectX诊断工具，最早作为DirectX6.0的一部分，在1998年8月发布。Dxdiag可以显示计算机上DirectX相关的文件，检查正在运行的文件、输入设备、以及视频驱动程序版本。还可以用来诊断和测试 DirectPlay、 DirectSound、 DirectMusic、 DirectDraw 和 Direct3D 的功能。
        //要运行DirectX诊断工具，单击开始 ，然后选择菜单项运行，在运行对话框中输入： dxdiag，单击确定，DirectX诊断工具就会被加载，即可出现Dxdiag对话框。
        //latitude 5400
        //Advanced BIOS Features 高级BIOS功能
        //Hard Disk Boot Priority 硬盘启动优先级
        //Startup Sequence 启动顺序
        //Mass Storage Driver  大容量存储驱动器
        //GAC是Global Assembly Cache，全局程序集缓存的简称
        //in advance 意思为事先 这个单词是个急性子，所以长度比较短 
        //advantage有优势、优点的意思，一般词组为 take the advantage of 利用。。。的优势，优点比较长
        //grep(Global Regular Expression Print)全局正则表达式搜索
        // (changeDirectory),命令语法：cd [目录名]。说明：切换当前目录至dirName
        //df命令的英文全称即“Disk Free”，顾名思义功能是用于显示系统上可使用的磁盘空间 
        //diskful 磁盘已满；
        //terminal 航空站;航空终点站;(火车、公共汽车或船的)终点站;终端;终端机;（电路的）端子，线接头 adj. 晚期的;不治的;致命的;患绝症的;不可救药的;无可挽回的;末端的
        // CLR(Common Language Runtime,译为公共语言运行时)是一个可由多种编程语言使用的“运行时”

        //表示小数的一共有三种类型：float是单精度，double是双精度，decimal是数字型，它们所占的内存空间不一样，表示的位数也不一样。
        //1、精度：
        //float单精度小数部分能精确到小数点后面6位，用 32 位二进制进行描述
        //double双精度小数部分能精确到小数点后的15位，，用64位二进制进行描述，比float型更精确
        //2、占内存及处理速度：
        //float单精度内存占4个字节
        //double双精度内存占8个字节，是float型的两倍，且运算速度也比float慢得多
        //结论：虽然double型比float型精度高，但由于占内存更大，运算速度慢，且即使是double依然会存在精度损失的问题，且不会报告任何的错误，也不会有任何的异常产生。所以如果涉及到小数计算的话，我们会用到下边的decimal型：
        //1、精度：
        //decimal用l128位高精度浮点数，常用于金融运算，不会出现浮点数计算的误差
        //2、占内存及处理速度：
        //decimal类型的数据存储形式是，将每9位十进制数存储为4个字节
        //举个例子：
        //1）字段decimal(5,2)，5-2=3，其中小数部分为2，对应上表1个字节，整数部分为3，对应上表2个字节
        //2）字段decimal(20,6)，20-6=14，其中小数部分为6，就对应上表中的3个字节，而整数部分为14，14-9=5，就是4个字节再加上表中的3个字节
        //结论：decimal型比浮点型计算精度要高，通常使用更少的空间。所以通常我们在设置小数的时候，都是用的decimal类型。
        //ProcessDesigner 进程- 设计师;设计者;构思者
        //Diagnostics 诊断学
        //ComponentModel 组件模型
    }
}
